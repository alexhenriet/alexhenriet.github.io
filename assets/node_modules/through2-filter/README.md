<h1 id="through2-filter">through2-filter</h1>

<p><a href="https://nodei.co/npm/through2-filter/"><img src="https://nodei.co/npm/through2-filter.png" alt="NPM" /></a></p>

<p>This is a super thin wrapper around <a href="http://npm.im/through2">through2</a> that works like <code>Array.prototype.filter</code> but for streams.</p>

<p>For when through2 is just too verbose :wink:</p>

<p>Note you will <strong>NOT</strong> be able to alter the content of the chunks. This is intended for filtering only. If you want to modify the stream content, use either <code>through2</code> or <code>through2-map</code>.</p>

<pre><code class="js">var filter = require("through2-filter")

var skip = filter(function (chunk) {
  // skip buffers longer than 100
  return chunk.length &lt; 100
})

// vs. with through2:
var skip = through2(function (chunk, encoding, callback) {
  // skip buffers longer than 100
  if (chunk.length &lt; 100) this.push(chunk)
  return callback()
})

// Then use your filter:
source.pipe(skip).pipe(sink)

// Additionally accepts `wantStrings` argument to conver buffers into strings
var alphanum = new RegExp("^[A-Za-z0-1]+$")
var scrub = filter({wantStrings: true}, function (str) {
  return alphanum.exec(str)
})

// Works like `Array.prototype.filter` meaning you can specify a function that
// takes up to two* arguments: fn(element, index)
var skip10 = filter(function (element, index) {
  return index &gt; 10
})
</code></pre>

<p>*Differences from <code>Array.prototype.filter</code>:
  * No third <code>array</code> callback argument. That would require realizing the entire stream, which is generally counter-productive to stream operations.
  * <code>Array.prototype.filter</code> doesn't modify the source Array, which is somewhat nonsensical when applied to streams.</p>

<h2 id="api">API</h2>

<h2 id="%60require%22through2-filter%22options%2C-fn%60"><code>require("through2-filter")([options], fn)</code></h2>

<p>Create a <code>through2-filter</code> instance that will call <code>fn(chunk)</code>. If <code>fn(chunk)</code> returns "true" the chunk will be passed downstream. Otherwise it will be dropped.</p>

<h2 id="%60require%22through2-filter%22.ctoroptions%2C-fn%60"><code>require("through2-filter").ctor([options], fn)</code></h2>

<p>Create a <code>through2-filter</code> Type that can be instantiated via <code>new Type()</code> or <code>Type()</code> to create reusable spies.</p>

<h2 id="%60require%22through2-filter%22.objoptions%2C-fn%60"><code>require("through2-filter").obj([options], fn)</code></h2>

<p>Create a <code>through2-filter</code> that defaults to <code>objectMode = true</code>.</p>

<h2 id="%60require%22through2-filter%22.objctoroptions%2C-fn%60"><code>require("through2-filter").objCtor([options], fn)</code></h2>

<p>Create a <code>through2-filter</code> Type that defaults to <code>objectMode = true</code>.</p>

<h2 id="options">Options</h2>

<ul>
<li>wantStrings: Automatically call chunk.toString() for the super lazy.</li>
<li>all other through2 options</li>
</ul>

<h1 id="license">LICENSE</h1>

<p>MIT</p>
