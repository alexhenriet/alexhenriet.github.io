<h1 id="fastq">fastq</h1>

<p><img src="https://github.com/mcollina/fastq/workflows/ci/badge.svg" alt="ci" />
<a href="https://badge.fury.io/js/fastq"><img src="https://badge.fury.io/js/fastq.svg" alt="npm version" /></a>
<a href="https://david-dm.org/mcollina/fastq"><img src="https://david-dm.org/mcollina/fastq.svg" alt="Dependency Status" /></a></p>

<p>Fast, in memory work queue.</p>

<p>Benchmarks (1 million tasks):</p>

<ul>
<li>setImmediate: 812ms</li>
<li>fastq: 854ms</li>
<li>async.queue: 1298ms</li>
<li>neoAsync.queue: 1249ms</li>
</ul>

<p>Obtained on node 12.16.1, on a dedicated server.</p>

<p>If you need zero-overhead series function call, check out
<a href="http://npm.im/fastseries">fastseries</a>. For zero-overhead parallel
function call, check out <a href="http://npm.im/fastparallel">fastparallel</a>.</p>

<p><a href="https://github.com/feross/standard"><img src="https://raw.githubusercontent.com/feross/standard/master/badge.png" alt="js-standard-style" /></a></p>

<ul>
<li><a href="#install">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#api">API</a></li>
<li><a href="#license">Licence &amp; copyright</a></li>
</ul>

<h2 id="install">Install</h2>

<p><code>npm i fastq --save</code></p>

<h2 id="usage-callback-api">Usage (callback API)</h2>

<pre><code class="js">'use strict'

const queue = require('fastq')(worker, 1)

queue.push(42, function (err, result) {
  if (err) { throw err }
  console.log('the result is', result)
})

function worker (arg, cb) {
  cb(null, arg * 2)
}
</code></pre>

<h2 id="usage-promise-api">Usage (promise API)</h2>

<pre><code class="js">const queue = require('fastq').promise(worker, 1)

async function worker (arg) {
  return arg * 2
}

async function run () {
  const result = await queue.push(42)
  console.log('the result is', result)
}

run()
</code></pre>

<h3 id="setting-%22this%22">Setting "this"</h3>

<pre><code class="js">'use strict'

const that = { hello: 'world' }
const queue = require('fastq')(that, worker, 1)

queue.push(42, function (err, result) {
  if (err) { throw err }
  console.log(this)
  console.log('the result is', result)
})

function worker (arg, cb) {
  console.log(this)
  cb(null, arg * 2)
}
</code></pre>

<h3 id="using-with-typescript-callback-api">Using with TypeScript (callback API)</h3>

<pre><code class="ts">'use strict'

import * as fastq from "fastq";
import type { queue, done } from "fastq";

type Task = {
  id: number
}

const q: queue&lt;Task&gt; = fastq(worker, 1)

q.push({ id: 42})

function worker (arg: Task, cb: done) {
  console.log(arg.id)
  cb(null)
}
</code></pre>

<h3 id="using-with-typescript-promise-api">Using with TypeScript (promise API)</h3>

<pre><code class="ts">'use strict'

import * as fastq from "fastq";
import type { queueAsPromised } from "fastq";

type Task = {
  id: number
}

const q: queueAsPromised&lt;Task&gt; = fastq.promise(asyncWorker, 1)

q.push({ id: 42}).catch((err) =&gt; console.error(err))

async function asyncWorker (arg: Task): Promise&lt;void&gt; {
  // No need for a try-catch block, fastq handles errors automatically
  console.log(arg.id)
}
</code></pre>

<h2 id="api">API</h2>

<ul>
<li><a href="#fastqueue"><code>fastqueue()</code></a></li>
<li><a href="#push"><code>queue#<b>push()</b></code></a></li>
<li><a href="#unshift"><code>queue#<b>unshift()</b></code></a></li>
<li><a href="#pause"><code>queue#<b>pause()</b></code></a></li>
<li><a href="#resume"><code>queue#<b>resume()</b></code></a></li>
<li><a href="#idle"><code>queue#<b>idle()</b></code></a></li>
<li><a href="#length"><code>queue#<b>length()</b></code></a></li>
<li><a href="#getQueue"><code>queue#<b>getQueue()</b></code></a></li>
<li><a href="#kill"><code>queue#<b>kill()</b></code></a></li>
<li><a href="#killAndDrain"><code>queue#<b>killAndDrain()</b></code></a></li>
<li><a href="#error"><code>queue#<b>error()</b></code></a></li>
<li><a href="#concurrency"><code>queue#<b>concurrency</b></code></a></li>
<li><a href="#drain"><code>queue#<b>drain</b></code></a></li>
<li><a href="#empty"><code>queue#<b>empty</b></code></a></li>
<li><a href="#saturated"><code>queue#<b>saturated</b></code></a></li>
<li><a href="#promise"><code>fastqueue.promise()</code></a></li>
</ul>

<hr />

<p><a name="fastqueue"></a></p>

<h3 id="fastqueuethat%2C-worker%2C-concurrency">fastqueue([that], worker, concurrency)</h3>

<p>Creates a new queue.</p>

<p>Arguments:</p>

<ul>
<li><code>that</code>, optional context of the <code>worker</code> function.</li>
<li><code>worker</code>, worker function, it would be called with <code>that</code> as <code>this</code>,
if that is specified.</li>
<li><code>concurrency</code>, number of concurrent tasks that could be executed in
parallel.</li>
</ul>

<hr />

<p><a name="push"></a></p>

<h3 id="queue.pushtask%2C-done">queue.push(task, done)</h3>

<p>Add a task at the end of the queue. <code>done(err, result)</code> will be called
when the task was processed.</p>

<hr />

<p><a name="unshift"></a></p>

<h3 id="queue.unshifttask%2C-done">queue.unshift(task, done)</h3>

<p>Add a task at the beginning of the queue. <code>done(err, result)</code> will be called
when the task was processed.</p>

<hr />

<p><a name="pause"></a></p>

<h3 id="queue.pause">queue.pause()</h3>

<p>Pause the processing of tasks. Currently worked tasks are not
stopped.</p>

<hr />

<p><a name="resume"></a></p>

<h3 id="queue.resume">queue.resume()</h3>

<p>Resume the processing of tasks.</p>

<hr />

<p><a name="idle"></a></p>

<h3 id="queue.idle">queue.idle()</h3>

<p>Returns <code>false</code> if there are tasks being processed or waiting to be processed.
<code>true</code> otherwise.</p>

<hr />

<p><a name="length"></a></p>

<h3 id="queue.length">queue.length()</h3>

<p>Returns the number of tasks waiting to be processed (in the queue).</p>

<hr />

<p><a name="getQueue"></a></p>

<h3 id="queue.getqueue">queue.getQueue()</h3>

<p>Returns all the tasks be processed (in the queue). Returns empty array when there are no tasks</p>

<hr />

<p><a name="kill"></a></p>

<h3 id="queue.kill">queue.kill()</h3>

<p>Removes all tasks waiting to be processed, and reset <code>drain</code> to an empty
function.</p>

<hr />

<p><a name="killAndDrain"></a></p>

<h3 id="queue.killanddrain">queue.killAndDrain()</h3>

<p>Same than <code>kill</code> but the <code>drain</code> function will be called before reset to empty.</p>

<hr />

<p><a name="error"></a></p>

<h3 id="queue.errorhandler">queue.error(handler)</h3>

<p>Set a global error handler. <code>handler(err, task)</code> will be called
when any of the tasks return an error.</p>

<hr />

<p><a name="concurrency"></a></p>

<h3 id="queue.concurrency">queue.concurrency</h3>

<p>Property that returns the number of concurrent tasks that could be executed in
parallel. It can be altered at runtime.</p>

<hr />

<p><a name="drain"></a></p>

<h3 id="queue.drain">queue.drain</h3>

<p>Function that will be called when the last
item from the queue has been processed by a worker.
It can be altered at runtime.</p>

<hr />

<p><a name="empty"></a></p>

<h3 id="queue.empty">queue.empty</h3>

<p>Function that will be called when the last
item from the queue has been assigned to a worker.
It can be altered at runtime.</p>

<hr />

<p><a name="saturated"></a></p>

<h3 id="queue.saturated">queue.saturated</h3>

<p>Function that will be called when the queue hits the concurrency
limit.
It can be altered at runtime.</p>

<hr />

<p><a name="promise"></a></p>

<h3 id="fastqueue.promisethat%2C-workerarg%2C-concurrency">fastqueue.promise([that], worker(arg), concurrency)</h3>

<p>Creates a new queue with <code>Promise</code> apis. It also offers all the methods
and properties of the object returned by <a href="#fastqueue"><code>fastqueue</code></a> with the modified
<a href="#pushPromise"><code>push</code></a> and <a href="#unshiftPromise"><code>unshift</code></a> methods.</p>

<p>Node v10+ is required to use the promisified version.</p>

<p>Arguments:
* <code>that</code>, optional context of the <code>worker</code> function.
* <code>worker</code>, worker function, it would be called with <code>that</code> as <code>this</code>,
  if that is specified. It MUST return a <code>Promise</code>.
* <code>concurrency</code>, number of concurrent tasks that could be executed in
  parallel.</p>

<p><a name="pushPromise"></a></p>

<h4 id="queue.pushtask-%3D%3E-promise">queue.push(task) => Promise</h4>

<p>Add a task at the end of the queue. The returned <code>Promise</code>  will be fulfilled (rejected)
when the task is completed successfully (unsuccessfully).</p>

<p>This promise could be ignored as it will not lead to a <code>'unhandledRejection'</code>.</p>

<p><a name="unshiftPromise"></a></p>

<h4 id="queue.unshifttask-%3D%3E-promise">queue.unshift(task) => Promise</h4>

<p>Add a task at the beginning of the queue. The returned <code>Promise</code>  will be fulfilled (rejected)
when the task is completed successfully (unsuccessfully).</p>

<p>This promise could be ignored as it will not lead to a <code>'unhandledRejection'</code>.</p>

<p><a name="drained"></a></p>

<h4 id="queue.drained-%3D%3E-promise">queue.drained() => Promise</h4>

<p>Wait for the queue to be drained. The returned <code>Promise</code> will be resolved when all tasks in the queue have been processed by a worker.</p>

<p>This promise could be ignored as it will not lead to a <code>'unhandledRejection'</code>.</p>

<h2 id="license">License</h2>

<p>ISC</p>
