<h1 id="fraction.js---%E2%84%9A-in-javascript">Fraction.js - ℚ in JavaScript</h1>

<p><a href="https://npmjs.org/package/fraction.js"><img src="https://nodei.co/npm-dl/fraction.js.png?months=6&amp;height=1" alt="NPM Package" /></a></p>

<p><a href="https://travis-ci.org/infusion/Fraction.js"><img src="https://travis-ci.org/infusion/Fraction.js.svg?branch=master" alt="Build Status" /></a>
<a href="http://opensource.org/licenses/MIT"><img src="http://img.shields.io/badge/license-MIT-brightgreen.svg" alt="MIT license" /></a></p>

<p>Tired of inprecise numbers represented by doubles, which have to store rational and irrational numbers like PI or sqrt(2) the same way? Obviously the following problem is preventable:</p>

<pre><code class="javascript">1 / 98 * 98 // = 0.9999999999999999
</code></pre>

<p>If you need more precision or just want a fraction as a result, have a look at <em>Fraction.js</em>:</p>

<pre><code class="javascript">var Fraction = require('fraction.js');

Fraction(1).div(98).mul(98) // = 1
</code></pre>

<p>Internally, numbers are represented as <em>numerator / denominator</em>, which adds just a little overhead. However, the library is written with performance in mind and outperforms any other implementation, as you can see <a href="http://jsperf.com/convert-a-rational-number-to-a-babylonian-fractions/28">here</a>. This basic data-type makes it the perfect basis for <a href="https://github.com/infusion/Polynomial.js">Polynomial.js</a> and <a href="https://github.com/josdejong/mathjs">Math.js</a>.</p>

<h1 id="convert-decimal-to-fraction">Convert decimal to fraction</h1>

<p>The simplest job for fraction.js is to get a fraction out of a decimal:</p>

<pre><code class="javascript">var x = new Fraction(1.88);
var res = x.toFraction(true); // String "1 22/25"
</code></pre>

<h1 id="examples-%2F-motivation">Examples / Motivation</h1>

<p>A simple example might be</p>

<pre><code class="javascript">var f = new Fraction("9.4'31'"); // 9.4313131313131...
f.mul([-4, 3]).mod("4.'8'"); // 4.88888888888888...
</code></pre>

<p>The result is</p>

<pre><code class="javascript">console.log(f.toFraction()); // -4154 / 1485
</code></pre>

<p>You could of course also access the sign (s), numerator (n) and denominator (d) on your own:</p>

<pre><code class="javascript">f.s * f.n / f.d = -1 * 4154 / 1485 = -2.797306...
</code></pre>

<p>If you would try to calculate it yourself, you would come up with something like:</p>

<pre><code class="javascript">(9.4313131 * (-4 / 3)) % 4.888888 = -2.797308133...
</code></pre>

<p>Quite okay, but yea - not as accurate as it could be.</p>

<h1 id="laplace-probability">Laplace Probability</h1>

<p>Simple example. What's the probability of throwing a 3, and 1 or 4, and 2 or 4 or 6 with a fair dice?</p>

<p>P({3}):</p>

<pre><code class="javascript">var p = new Fraction([3].length, 6).toString(); // 0.1(6)
</code></pre>

<p>P({1, 4}):</p>

<pre><code class="javascript">var p = new Fraction([1, 4].length, 6).toString(); // 0.(3)
</code></pre>

<p>P({2, 4, 6}):</p>

<pre><code class="javascript">var p = new Fraction([2, 4, 6].length, 6).toString(); // 0.5
</code></pre>

<h1 id="convert-degrees%2Fminutes%2Fseconds-to-precise-rational-representation%3A">Convert degrees/minutes/seconds to precise rational representation:</h1>

<p>57+45/60+17/3600</p>

<pre><code class="javascript">var deg = 57; // 57°
var min = 45; // 45 Minutes
var sec = 17; // 17 Seconds

new Fraction(deg).add(min, 60).add(sec, 3600).toString() // -&gt; 57.7547(2)
</code></pre>

<h1 id="rounding-a-fraction-to-the-closest-tape-measure-value">Rounding a fraction to the closest tape measure value</h1>

<p>A tape measure is usually divided in parts of <code>1/16</code>. Rounding a given fraction to the closest value on a tape measure can be determined by</p>

<pre><code class="javascript">function closestTapeMeasure(frac) {

    /*
    k/16 ≤ a/b &lt; (k+1)/16
    ⇔ k ≤ 16*a/b &lt; (k+1)
    ⇔ k = floor(16*a/b)
    */
    return new Fraction(Math.round(16 * Fraction(frac).valueOf()), 16);
}
// closestTapeMeasure("1/3") // 5/16
</code></pre>

<h1 id="rational-approximation-of-irrational-numbers">Rational approximation of irrational numbers</h1>

<p>Now it's getting messy ;d To approximate a number like <em>sqrt(5) - 2</em> with a numerator and denominator, you can reformat the equation as follows: <em>pow(n / d + 2, 2) = 5</em>.</p>

<p>Then the following algorithm will generate the rational number besides the binary representation.</p>

<pre><code class="javascript">var x = "/", s = "";

var a = new Fraction(0),
    b = new Fraction(1);
for (var n = 0; n &lt;= 10; n++) {

  var c = a.add(b).div(2);

  console.log(n + "\t" + a + "\t" + b + "\t" + c + "\t" + x);

  if (c.add(2).pow(2) &lt; 5) {
    a = c;
    x = "1";
  } else {
    b = c;
    x = "0";
  }
  s+= x;
}
console.log(s)
</code></pre>

<p>The result is</p>

<pre><code>n   a[n]        b[n]        c[n]            x[n]
0   0/1         1/1         1/2             /
1   0/1         1/2         1/4             0
2   0/1         1/4         1/8             0
3   1/8         1/4         3/16            1
4   3/16        1/4         7/32            1
5   7/32        1/4         15/64           1
6   15/64       1/4         31/128          1
7   15/64       31/128      61/256          0
8   15/64       61/256      121/512         0
9   15/64       121/512     241/1024        0
10  241/1024    121/512     483/2048        1
</code></pre>

<p>Thus the approximation after 11 iterations of the bisection method is <em>483 / 2048</em> and the binary representation is 0.00111100011 (see <a href="http://www.wolframalpha.com/input/?i=sqrt%285%29-2+binary">WolframAlpha</a>)</p>

<p>I published another example on how to approximate PI with fraction.js on my <a href="http://www.xarg.org/2014/03/precise-calculations-in-javascript/">blog</a> (Still not the best idea to approximate irrational numbers, but it illustrates the capabilities of Fraction.js perfectly).</p>

<h2 id="get-the-exact-fractional-part-of-a-number">Get the exact fractional part of a number</h2>

<pre><code class="javascript">var f = new Fraction("-6.(3416)");
console.log("" + f.mod(1).abs()); // Will print 0.(3416)
</code></pre>

<h2 id="mathematical-correct-modulo">Mathematical correct modulo</h2>

<p>The behaviour on negative congruences is different to most modulo implementations in computer science. Even the <em>mod()</em> function of Fraction.js behaves in the typical way. To solve the problem of having the mathematical correct modulo with Fraction.js you could come up with this:</p>

<pre><code class="javascript">var a = -1;
var b = 10.99;

console.log(new Fraction(a)
  .mod(b)); // Not correct, usual Modulo

console.log(new Fraction(a)
  .mod(b).add(b).mod(b)); // Correct! Mathematical Modulo
</code></pre>

<h2 id="fmod-impreciseness-circumvented">fmod() impreciseness circumvented</h2>

<p>It turns out that Fraction.js outperforms almost any fmod() implementation, including JavaScript itself, <a href="http://phpjs.org/functions/fmod/">php.js</a>, C++, Python, Java and even Wolframalpha due to the fact that numbers like 0.05, 0.1, ... are infinite decimal in base 2.</p>

<p>The equation <em>fmod(4.55, 0.05)</em> gives <em>0.04999999999999957</em>, wolframalpha says <em>1/20</em>. The correct answer should be <strong>zero</strong>, as 0.05 divides 4.55 without any remainder.</p>

<h1 id="parser">Parser</h1>

<p>Any function (see below) as well as the constructor of the <em>Fraction</em> class parses its input and reduce it to the smallest term.</p>

<p>You can pass either Arrays, Objects, Integers, Doubles or Strings.</p>

<h2 id="arrays-%2F-objects">Arrays / Objects</h2>

<pre><code class="javascript">new Fraction(numerator, denominator);
new Fraction([numerator, denominator]);
new Fraction({n: numerator, d: denominator});
</code></pre>

<h2 id="integers">Integers</h2>

<pre><code class="javascript">new Fraction(123);
</code></pre>

<h2 id="doubles">Doubles</h2>

<pre><code class="javascript">new Fraction(55.4);
</code></pre>

<p><strong>Note:</strong> If you pass a double as it is, Fraction.js will perform a number analysis based on Farey Sequences. If you concern performance, cache Fraction.js objects and pass arrays/objects.</p>

<p>The method is really precise, but too large exact numbers, like 1234567.9991829 will result in a wrong approximation. If you want to keep the number as it is, convert it to a string, as the string parser will not perform any further observations. If you have problems with the approximation, in the file <code>examples/approx.js</code> is a different approximation algorithm, which might work better in some more specific use-cases.</p>

<h2 id="strings">Strings</h2>

<pre><code class="javascript">new Fraction("123.45");
new Fraction("123/45"); // A rational number represented as two decimals, separated by a slash
new Fraction("123:45"); // A rational number represented as two decimals, separated by a colon
new Fraction("4 123/45"); // A rational number represented as a whole number and a fraction
new Fraction("123.'456'"); // Note the quotes, see below!
new Fraction("123.(456)"); // Note the brackets, see below!
new Fraction("123.45'6'"); // Note the quotes, see below!
new Fraction("123.45(6)"); // Note the brackets, see below!
</code></pre>

<h2 id="two-arguments">Two arguments</h2>

<pre><code class="javascript">new Fraction(3, 2); // 3/2 = 1.5
</code></pre>

<h2 id="repeating-decimal-places">Repeating decimal places</h2>

<p><em>Fraction.js</em> can easily handle repeating decimal places. For example <em>1/3</em> is <em>0.3333...</em>. There is only one repeating digit. As you can see in the examples above, you can pass a number like <em>1/3</em> as "0.'3'" or "0.(3)", which are synonym. There are no tests to parse something like 0.166666666 to 1/6! If you really want to handle this number, wrap around brackets on your own with the function below for example: 0.1(66666666)</p>

<p>Assume you want to divide 123.32 / 33.6(567). <a href="http://www.wolframalpha.com/input/?i=123.32+%2F+%2812453%2F370%29">WolframAlpha</a> states that you'll get a period of 1776 digits. <em>Fraction.js</em> comes to the same result. Give it a try:</p>

<pre><code class="javascript">var f = new Fraction("123.32");
console.log("Bam: " + f.div("33.6(567)"));
</code></pre>

<p>To automatically make a number like "0.123123123" to something more Fraction.js friendly like "0.(123)", I hacked this little brute force algorithm in a 10 minutes. Improvements are welcome...</p>

<pre><code class="javascript">function formatDecimal(str) {

  var comma, pre, offset, pad, times, repeat;

  if (-1 === (comma = str.indexOf(".")))
    return str;

  pre = str.substr(0, comma + 1);
  str = str.substr(comma + 1);

  for (var i = 0; i &lt; str.length; i++) {

    offset = str.substr(0, i);

    for (var j = 0; j &lt; 5; j++) {

      pad = str.substr(i, j + 1);

      times = Math.ceil((str.length - offset.length) / pad.length);

      repeat = new Array(times + 1).join(pad); // Silly String.repeat hack

      if (0 === (offset + repeat).indexOf(str)) {
        return pre + offset + "(" + pad + ")";
      }
    }
  }
  return null;
}

var f, x = formatDecimal("13.0123123123"); // = 13.0(123)
if (x !== null) {
  f = new Fraction(x);
}
</code></pre>

<h1 id="attributes">Attributes</h1>

<p>The Fraction object allows direct access to the numerator, denominator and sign attributes. It is ensured that only the sign-attribute holds sign information so that a sign comparison is only necessary against this attribute.</p>

<pre><code class="javascript">var f = new Fraction('-1/2');
console.log(f.n); // Numerator: 1
console.log(f.d); // Denominator: 2
console.log(f.s); // Sign: -1
</code></pre>

<h1 id="functions">Functions</h1>

<h2 id="fraction-abs">Fraction abs()</h2>

<p>Returns the actual number without any sign information</p>

<h2 id="fraction-neg">Fraction neg()</h2>

<p>Returns the actual number with flipped sign in order to get the additive inverse</p>

<h2 id="fraction-addn">Fraction add(n)</h2>

<p>Returns the sum of the actual number and the parameter n</p>

<h2 id="fraction-subn">Fraction sub(n)</h2>

<p>Returns the difference of the actual number and the parameter n</p>

<h2 id="fraction-muln">Fraction mul(n)</h2>

<p>Returns the product of the actual number and the parameter n</p>

<h2 id="fraction-divn">Fraction div(n)</h2>

<p>Returns the quotient of the actual number and the parameter n</p>

<h2 id="fraction-powexp">Fraction pow(exp)</h2>

<p>Returns the power of the actual number, raised to an possible rational exponent. If the result becomes non-rational the function returns <code>null</code>.</p>

<h2 id="fraction-modn">Fraction mod(n)</h2>

<p>Returns the modulus (rest of the division) of the actual object and n (this % n). It's a much more precise <a href="#fmod-impreciseness-circumvented">fmod()</a> if you will. Please note that <em>mod()</em> is just like the modulo operator of most programming languages. If you want a mathematical correct modulo, see <a href="#mathematical-correct-modulo">here</a>.</p>

<h2 id="fraction-mod">Fraction mod()</h2>

<p>Returns the modulus (rest of the division) of the actual object (numerator mod denominator)</p>

<h2 id="fraction-gcdn">Fraction gcd(n)</h2>

<p>Returns the fractional greatest common divisor</p>

<h2 id="fraction-lcmn">Fraction lcm(n)</h2>

<p>Returns the fractional least common multiple</p>

<h2 id="fraction-ceilplaces%3D0-16">Fraction ceil([places=0-16])</h2>

<p>Returns the ceiling of a rational number with Math.ceil</p>

<h2 id="fraction-floorplaces%3D0-16">Fraction floor([places=0-16])</h2>

<p>Returns the floor of a rational number with Math.floor</p>

<h2 id="fraction-roundplaces%3D0-16">Fraction round([places=0-16])</h2>

<p>Returns the rational number rounded with Math.round</p>

<h2 id="fraction-inverse">Fraction inverse()</h2>

<p>Returns the multiplicative inverse of the actual number (n / d becomes d / n) in order to get the reciprocal</p>

<h2 id="fraction-simplifyeps%3D0.001">Fraction simplify([eps=0.001])</h2>

<p>Simplifies the rational number under a certain error threshold. Ex. <code>0.333</code> will be <code>1/3</code> with <code>eps=0.001</code></p>

<h2 id="boolean-equalsn">boolean equals(n)</h2>

<p>Check if two numbers are equal</p>

<h2 id="int-comparen">int compare(n)</h2>

<p>Compare two numbers.</p>

<pre><code>result &lt; 0: n is greater than actual number
result &gt; 0: n is smaller than actual number
result = 0: n is equal to the actual number
</code></pre>

<h2 id="boolean-divisiblen">boolean divisible(n)</h2>

<p>Check if two numbers are divisible (n divides this)</p>

<h2 id="double-valueof">double valueOf()</h2>

<p>Returns a decimal representation of the fraction</p>

<h2 id="string-tostringdecimalplaces%3D15">String toString([decimalPlaces=15])</h2>

<p>Generates an exact string representation of the actual object. For repeated decimal places all digits are collected within brackets, like <code>1/3 = "0.(3)"</code>. For all other numbers, up to <code>decimalPlaces</code> significant digits are collected - which includes trailing zeros if the number is getting truncated. However, <code>1/2 = "0.5"</code> without trailing zeros of course.</p>

<p><strong>Note:</strong> As <code>valueOf()</code> and <code>toString()</code> are provided, <code>toString()</code> is only called implicitly in a real string context. Using the plus-operator like <code>"123" + new Fraction</code> will call valueOf(), because JavaScript tries to combine two primitives first and concatenates them later, as string will be the more dominant type. <code>alert(new Fraction)</code> or <code>String(new Fraction)</code> on the other hand will do what you expect. If you really want to have control, you should call <code>toString()</code> or <code>valueOf()</code> explicitly!</p>

<h2 id="string-tolatexexcludewhole%3Dfalse">String toLatex(excludeWhole=false)</h2>

<p>Generates an exact LaTeX representation of the actual object. You can see a <a href="http://www.xarg.org/2014/03/precise-calculations-in-javascript/">live demo</a> on my blog.</p>

<p>The optional boolean parameter indicates if you want to exclude the whole part. "1 1/3" instead of "4/3"</p>

<h2 id="string-tofractionexcludewhole%3Dfalse">String toFraction(excludeWhole=false)</h2>

<p>Gets a string representation of the fraction</p>

<p>The optional boolean parameter indicates if you want to exclude the whole part. "1 1/3" instead of "4/3"</p>

<h2 id="array-tocontinued">Array toContinued()</h2>

<p>Gets an array of the fraction represented as a continued fraction. The first element always contains the whole part.</p>

<pre><code class="javascript">var f = new Fraction('88/33');
var c = f.toContinued(); // [2, 1, 2]
</code></pre>

<h2 id="fraction-clone">Fraction clone()</h2>

<p>Creates a copy of the actual Fraction object</p>

<h1 id="exceptions">Exceptions</h1>

<p>If a really hard error occurs (parsing error, division by zero), <em>fraction.js</em> throws exceptions! Please make sure you handle them correctly.</p>

<h1 id="installation">Installation</h1>

<p>Installing fraction.js is as easy as cloning this repo or use one of the following commands:</p>

<pre><code>bower install fraction.js
</code></pre>

<p>or</p>

<pre><code>npm install fraction.js
</code></pre>

<h1 id="using-fraction.js-with-the-browser">Using Fraction.js with the browser</h1>

<pre><code class="html">&lt;script src="fraction.js"&gt;&lt;/script&gt;
&lt;script&gt;
    console.log(Fraction("123/456"));
&lt;/script&gt;
</code></pre>

<h1 id="using-fraction.js-with-require.js">Using Fraction.js with require.js</h1>

<pre><code class="html">&lt;script src="require.js"&gt;&lt;/script&gt;
&lt;script&gt;
requirejs(['fraction.js'],
function(Fraction) {
    console.log(Fraction("123/456"));
});
&lt;/script&gt;
</code></pre>

<h1 id="using-fraction.js-with-typescript">Using Fraction.js with TypeScript</h1>

<pre><code class="js">import Fraction from "fraction.js";
console.log(Fraction("123/456"));
</code></pre>

<h1 id="coding-style">Coding Style</h1>

<p>As every library I publish, fraction.js is also built to be as small as possible after compressing it with Google Closure Compiler in advanced mode. Thus the coding style orientates a little on maxing-out the compression rate. Please make sure you keep this style if you plan to extend the library.</p>

<h1 id="precision">Precision</h1>

<p>Fraction.js tries to circumvent floating point errors, by having an internal representation of numerator and denominator. As it relies on JavaScript, there is also a limit. The biggest number representable is <code>Number.MAX_SAFE_INTEGER / 1</code> and the smallest is <code>-1 / Number.MAX_SAFE_INTEGER</code>, with <code>Number.MAX_SAFE_INTEGER=9007199254740991</code>. If this is not enough, there is <code>bigfraction.js</code> shipped experimentally, which relies on <code>BigInt</code> and should become the new Fraction.js eventually.</p>

<h1 id="testing">Testing</h1>

<p>If you plan to enhance the library, make sure you add test cases and all the previous tests are passing. You can test the library with</p>

<pre><code>npm test
</code></pre>

<h1 id="copyright-and-licensing">Copyright and licensing</h1>

<p>Copyright (c) 2014-2019, <a href="https://www.xarg.org/">Robert Eisele</a>
Dual licensed under the MIT or GPL Version 2 licenses.</p>
