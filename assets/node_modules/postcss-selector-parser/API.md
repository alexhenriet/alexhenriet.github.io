<h1 id="api-documentation">API Documentation</h1>

<p><em>Please use only this documented API when working with the parser. Methods
not documented here are subject to change at any point.</em></p>

<h2 id="%60parser%60-function"><code>parser</code> function</h2>

<p>This is the module's main entry point.</p>

<pre><code class="js">var parser = require('postcss-selector-parser');
</code></pre>

<h3 id="%60parsertransform%60"><code>parser([transform])</code></h3>

<p>Creates a new <code>processor</code> instance</p>

<pre><code class="js">var processor = parser();

// or, with optional transform function
var transform = function (selectors) {
    selectors.eachUniversal(function (selector) {
        selector.remove();
    });
};

var processor = parser(transform)

// Example
var result = processor.process('*.class').result;
// =&gt; .class
</code></pre>

<p><a href="#processor">See processor documentation</a></p>

<p>Arguments:</p>

<ul>
<li><code>transform (function)</code>: Provide a function to work with the parsed AST.</li>
</ul>

<h3 id="%60parser.attributeprops%60"><code>parser.attribute([props])</code></h3>

<p>Creates a new attribute selector.</p>

<pre><code class="js">parser.attribute({attribute: 'href'});
// =&gt; [href]
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.classnameprops%60"><code>parser.className([props])</code></h3>

<p>Creates a new class selector.</p>

<pre><code class="js">parser.className({value: 'button'});
// =&gt; .button
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.combinatorprops%60"><code>parser.combinator([props])</code></h3>

<p>Creates a new selector combinator.</p>

<pre><code class="js">parser.combinator({value: '+'});
// =&gt; +
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.commentprops%60"><code>parser.comment([props])</code></h3>

<p>Creates a new comment.</p>

<pre><code class="js">parser.comment({value: '/* Affirmative, Dave. I read you. */'});
// =&gt; /* Affirmative, Dave. I read you. */
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.idprops%60"><code>parser.id([props])</code></h3>

<p>Creates a new id selector.</p>

<pre><code class="js">parser.id({value: 'search'});
// =&gt; #search
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.nestingprops%60"><code>parser.nesting([props])</code></h3>

<p>Creates a new nesting selector.</p>

<pre><code class="js">parser.nesting();
// =&gt; &amp;
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.pseudoprops%60"><code>parser.pseudo([props])</code></h3>

<p>Creates a new pseudo selector.</p>

<pre><code class="js">parser.pseudo({value: '::before'});
// =&gt; ::before
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.rootprops%60"><code>parser.root([props])</code></h3>

<p>Creates a new root node.</p>

<pre><code class="js">parser.root();
// =&gt; (empty)
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.selectorprops%60"><code>parser.selector([props])</code></h3>

<p>Creates a new selector node.</p>

<pre><code class="js">parser.selector();
// =&gt; (empty)
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.stringprops%60"><code>parser.string([props])</code></h3>

<p>Creates a new string node.</p>

<pre><code class="js">parser.string();
// =&gt; (empty)
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.tagprops%60"><code>parser.tag([props])</code></h3>

<p>Creates a new tag selector.</p>

<pre><code class="js">parser.tag({value: 'button'});
// =&gt; button
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h3 id="%60parser.universalprops%60"><code>parser.universal([props])</code></h3>

<p>Creates a new universal selector.</p>

<pre><code class="js">parser.universal();
// =&gt; *
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>

<h2 id="node-types">Node types</h2>

<h3 id="%60node.type%60"><code>node.type</code></h3>

<p>A string representation of the selector type. It can be one of the following;
<code>attribute</code>, <code>class</code>, <code>combinator</code>, <code>comment</code>, <code>id</code>, <code>nesting</code>, <code>pseudo</code>,
<code>root</code>, <code>selector</code>, <code>string</code>, <code>tag</code>, or <code>universal</code>. Note that for convenience,
these constants are exposed on the main <code>parser</code> as uppercased keys. So for
example you can get <code>id</code> by querying <code>parser.ID</code>.</p>

<pre><code class="js">parser.attribute({attribute: 'href'}).type;
// =&gt; 'attribute'
</code></pre>

<h3 id="%60node.parent%60"><code>node.parent</code></h3>

<p>Returns the parent node.</p>

<pre><code class="js">root.nodes[0].parent === root;
</code></pre>

<h3 id="%60node.tostring%60%2C-%60stringnode%60%2C-or-%60%27%27-%2B-node%60"><code>node.toString()</code>, <code>String(node)</code>, or <code>'' + node</code></h3>

<p>Returns a string representation of the node.</p>

<pre><code class="js">var id = parser.id({value: 'search'});
console.log(String(id));
// =&gt; #search
</code></pre>

<h3 id="%60node.next%60-%26-%60node.prev%60"><code>node.next()</code> &amp; <code>node.prev()</code></h3>

<p>Returns the next/previous child of the parent node.</p>

<pre><code class="js">var next = id.next();
if (next &amp;&amp; next.type !== 'combinator') {
    throw new Error('Qualified IDs are not allowed!');
}
</code></pre>

<h3 id="%60node.replacewithnode%60"><code>node.replaceWith(node)</code></h3>

<p>Replace a node with another.</p>

<pre><code class="js">var attr = selectors.first.first;
var className = parser.className({value: 'test'});
attr.replaceWith(className);
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>node</code>: The node to substitute the original with.</li>
</ul>

<h3 id="%60node.remove%60"><code>node.remove()</code></h3>

<p>Removes the node from its parent node.</p>

<pre><code class="js">if (node.type === 'id') {
    node.remove();
}
</code></pre>

<h3 id="%60node.clone%60"><code>node.clone()</code></h3>

<p>Returns a copy of a node, detached from any parent containers that the
original might have had.</p>

<pre><code class="js">var cloned = parser.id({value: 'search'});
String(cloned);

// =&gt; #search
</code></pre>

<h3 id="%60node.spaces%60"><code>node.spaces</code></h3>

<p>Extra whitespaces around the node will be moved into <code>node.spaces.before</code> and
<code>node.spaces.after</code>. So for example, these spaces will be moved as they have
no semantic meaning:</p>

<pre><code class="css">      h1     ,     h2   {}
</code></pre>

<p>However, <em>combinating</em> spaces will form a <code>combinator</code> node:</p>

<pre><code class="css">h1        h2 {}
</code></pre>

<p>A <code>combinator</code> node may only have the <code>spaces</code> property set if the combinator
value is a non-whitespace character, such as <code>+</code>, <code>~</code> or <code>&gt;</code>. Otherwise, the
combinator value will contain all of the spaces between selectors.</p>

<h3 id="%60node.source%60"><code>node.source</code></h3>

<p>An object describing the node's start/end, line/column source position.</p>

<p>Within the following CSS, the <code>.bar</code> class node ...</p>

<pre><code class="css">.foo,
  .bar {}
</code></pre>

<p>... will contain the following <code>source</code> object.</p>

<pre><code class="js">source: {
    start: {
        line: 2,
        column: 3
    },
    end: {
        line: 2,
        column: 6
    }
}
</code></pre>

<h3 id="%60node.sourceindex%60"><code>node.sourceIndex</code></h3>

<p>The zero-based index of the node within the original source string.</p>

<p>Within the following CSS, the <code>.baz</code> class node will have a <code>sourceIndex</code> of <code>12</code>.</p>

<pre><code class="css">.foo, .bar, .baz {}
</code></pre>

<h2 id="container-types">Container types</h2>

<p>The <code>root</code>, <code>selector</code>, and <code>pseudo</code> nodes have some helper methods for working
with their children.</p>

<h3 id="%60container.nodes%60"><code>container.nodes</code></h3>

<p>An array of the container's children.</p>

<pre><code class="js">// Input: h1 h2
selectors.at(0).nodes.length   // =&gt; 3
selectors.at(0).nodes[0].value // =&gt; 'h1'
selectors.at(0).nodes[1].value // =&gt; ' '
</code></pre>

<h3 id="%60container.first%60-%26-%60container.last%60"><code>container.first</code> &amp; <code>container.last</code></h3>

<p>The first/last child of the container.</p>

<pre><code class="js">selector.first === selector.nodes[0];
selector.last === selector.nodes[selector.nodes.length - 1];
</code></pre>

<h3 id="%60container.atindex%60"><code>container.at(index)</code></h3>

<p>Returns the node at position <code>index</code>.</p>

<pre><code class="js">selector.at(0) === selector.first;
selector.at(0) === selector.nodes[0];
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>index</code>: The index of the node to return.</li>
</ul>

<h3 id="%60container.indexnode%60"><code>container.index(node)</code></h3>

<p>Return the index of the node within its container.</p>

<pre><code class="js">selector.index(selector.nodes[2]) // =&gt; 2
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>node</code>: A node within the current container.</li>
</ul>

<h3 id="%60container.length%60"><code>container.length</code></h3>

<p>Proxy to the length of the container's nodes.</p>

<pre><code class="js">container.length === container.nodes.length
</code></pre>

<h3 id="%60container%60-array-iterators"><code>container</code> Array iterators</h3>

<p>The container class provides proxies to certain Array methods; these are:</p>

<ul>
<li><code>container.map === container.nodes.map</code></li>
<li><code>container.reduce === container.nodes.reduce</code></li>
<li><code>container.every === container.nodes.every</code></li>
<li><code>container.some === container.nodes.some</code></li>
<li><code>container.filter === container.nodes.filter</code></li>
<li><code>container.sort === container.nodes.sort</code></li>
</ul>

<p>Note that these methods only work on a container's immediate children; recursive
iteration is provided by <code>container.walk</code>.</p>

<h3 id="%60container.eachcallback%60"><code>container.each(callback)</code></h3>

<p>Iterate the container's immediate children, calling <code>callback</code> for each child.
You may return <code>false</code> within the callback to break the iteration.</p>

<pre><code class="js">var className;
selectors.each(function (selector, index) {
    if (selector.type === 'class') {
        className = selector.value;
        return false;
    }
});
</code></pre>

<p>Note that unlike <code>Array#forEach()</code>, this iterator is safe to use whilst adding
or removing nodes from the container.</p>

<p>Arguments:</p>

<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>

<h3 id="%60container.walkcallback%60"><code>container.walk(callback)</code></h3>

<p>Like <code>container#each</code>, but will also iterate child nodes as long as they are
<code>container</code> types.</p>

<pre><code class="js">selectors.walk(function (selector, index) {
    // all nodes
});
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>

<p>This iterator is safe to use whilst mutating <code>container.nodes</code>,
like <code>container#each</code>.</p>

<h3 id="%60container.walk%60-proxies"><code>container.walk</code> proxies</h3>

<p>The container class provides proxy methods for iterating over types of nodes,
so that it is easier to write modules that target specific selectors. Those
methods are:</p>

<ul>
<li><code>container.walkAttributes</code></li>
<li><code>container.walkClasses</code></li>
<li><code>container.walkCombinators</code></li>
<li><code>container.walkComments</code></li>
<li><code>container.walkIds</code></li>
<li><code>container.walkNesting</code></li>
<li><code>container.walkPseudos</code></li>
<li><code>container.walkTags</code></li>
<li><code>container.walkUniversals</code></li>
</ul>

<h3 id="%60container.splitcallback%60"><code>container.split(callback)</code></h3>

<p>This method allows you to split a group of nodes by returning <code>true</code> from
a callback. It returns an array of arrays, where each inner array corresponds
to the groups that you created via the callback.</p>

<pre><code class="js">// (input) =&gt; h1 h2&gt;&gt;h3
var list = selectors.first.split((selector) =&gt; {
    return selector.type === 'combinator';
});

// (node values) =&gt; [['h1', ' '], ['h2', '&gt;&gt;'], ['h3']]
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
as an argument.</li>
</ul>

<h3 id="%60container.prependnode%60-%26-%60container.appendnode%60"><code>container.prepend(node)</code> &amp; <code>container.append(node)</code></h3>

<p>Add a node to the start/end of the container. Note that doing so will set
the parent property of the node to this container.</p>

<pre><code class="js">var id = parser.id({value: 'search'});
selector.append(id);
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>node</code>: The node to add.</li>
</ul>

<h3 id="%60container.insertbeforeold%2C-new%60-%26-%60container.insertafterold%2C-new%60"><code>container.insertBefore(old, new)</code> &amp; <code>container.insertAfter(old, new)</code></h3>

<p>Add a node before or after an existing node in a container:</p>

<pre><code class="js">selectors.walk(function (selector) {
    if (selector.type !== 'class') {
        var className = parser.className({value: 'theme-name'});
        selector.parent.insertAfter(selector, className);
    }
});
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>old</code>: The existing node in the container.</li>
<li><code>new</code>: The new node to add before/after the existing node.</li>
</ul>

<h3 id="%60container.removechildnode%60"><code>container.removeChild(node)</code></h3>

<p>Remove the node from the container. Note that you can also use
<code>node.remove()</code> if you would like to remove just a single node.</p>

<pre><code class="js">selector.length // =&gt; 2
selector.remove(id)
selector.length // =&gt; 1;
id.parent       // undefined
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>node</code>: The node to remove.</li>
</ul>

<h3 id="%60container.removeall%60-or-%60container.empty%60"><code>container.removeAll()</code> or <code>container.empty()</code></h3>

<p>Remove all children from the container.</p>

<pre><code class="js">selector.removeAll();
selector.length // =&gt; 0
</code></pre>

<h2 id="root-nodes">Root nodes</h2>

<p>A root node represents a comma separated list of selectors. Indeed, all
a root's <code>toString()</code> method does is join its selector children with a ','.
Other than this, it has no special functionality and acts like a container.</p>

<h3 id="%60root.trailingcomma%60"><code>root.trailingComma</code></h3>

<p>This will be set to <code>true</code> if the input has a trailing comma, in order to
support parsing of legacy CSS hacks.</p>

<h2 id="selector-nodes">Selector nodes</h2>

<p>A selector node represents a single compound selector. For example, this
selector string <code>h1 h2 h3, [href] &gt; p</code>, is represented as two selector nodes.
It has no special functionality of its own.</p>

<h2 id="pseudo-nodes">Pseudo nodes</h2>

<p>A pseudo selector extends a container node; if it has any parameters of its
own (such as <code>h1:not(h2, h3)</code>), they will be its children. Note that the pseudo
<code>value</code> will always contain the colons preceding the pseudo identifier. This
is so that both <code>:before</code> and <code>::before</code> are properly represented in the AST.</p>

<h2 id="attribute-nodes">Attribute nodes</h2>

<h3 id="%60attribute.quoted%60"><code>attribute.quoted</code></h3>

<p>Returns <code>true</code> if the attribute's value is wrapped in quotation marks, false if it is not.
Remains <code>undefined</code> if there is no attribute value.</p>

<pre><code class="css">[href=foo] /* false */
[href='foo'] /* true */
[href="foo"] /* true */
[href] /* undefined */
</code></pre>

<h3 id="%60attribute.raws.unquoted%60"><code>attribute.raws.unquoted</code></h3>

<p>Returns the unquoted content of the attribute's value.
Remains <code>undefined</code> if there is no attribute value.</p>

<pre><code class="css">[href=foo] /* foo */
[href='foo'] /* foo */
[href="foo"] /* foo */
[href] /* undefined */
</code></pre>

<h3 id="%60attribute.raws.insensitive%60"><code>attribute.raws.insensitive</code></h3>

<p>If there is an <code>i</code> specifying case insensitivity, returns that <code>i</code> along with the whitespace
around it.</p>

<pre><code class="css">[id=Bar i ] /* " i " */
[id=Bar   i  ] /* "   i  " */
</code></pre>

<h2 id="%60processor%60"><code>processor</code></h2>

<h3 id="%60processcsstext%2C-options%60"><code>process(cssText, [options])</code></h3>

<p>Processes the <code>cssText</code>, returning the parsed output</p>

<pre><code class="js">var processor = parser();

var result = processor.process(' .class').result;
// =&gt;  .class

// To have the parser normalize whitespace values, utilize the options
var result = processor.process('  .class  ', {lossless: false}).result;
// =&gt; .class
</code></pre>

<p>Arguments:</p>

<ul>
<li><code>cssText (string)</code>: The css to be parsed.</li>
<li><code>[options] (object)</code>: Process options</li>
</ul>

<p>Options:</p>

<ul>
<li><code>lossless (boolean)</code>: false to normalize the selector whitespace, defaults to true</li>
</ul>
